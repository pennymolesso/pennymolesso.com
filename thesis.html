<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link href="css/staticrypt.css" rel="stylesheet" type="text/css" media="all">
        <link href="https://fonts.googleapis.com/css2?family=Averia+Serif+Libre:wght@300&display=swap" rel="stylesheet">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"48c43c72e439e5e6f249b5b3272f108fb79de563722bfc9b67697ca5d84cee2efcffad0036803b678686b9f1834ad8a97ae65f1900b347e59eeaf986eabae24145a3fd7061cf766899e0cae3a53be9d08c253c65ff451ab4bbf8ea21525e8a0f01612b95911657d85f06a8e44ade98998a53faccba56845011035a277958dec51cc82d6f95681599187d22144dd55ca93439cb1659dea7707c6ed61385f342e6a4f85dc894c11339a772a481f02e880b875c2dfba1545460fb07ecc3454a7fc5106b822af336ae3c2005147e582451400974d3521a5f25d64fd05d8e56bdfe0facb41f2e5b1632d1635a1e674a375fdd3c4dd02c49e62a613d9483c57d5d1d1a5b020b419ed21b756f6fb6997c63c41dbbb7aa1f1d9f45edc61d33fd79c4314565121c795d06b889ead0ff8da0dd7a7888a9f24eacb7062ff2e828f0936fe86299d077109c7daea113349fb8ef46d0503cb249dba91f96a5992d421f1b19f892caf5e5aafdad16ddddefdfa36664e356cdcb7e90e3274dc6dd39f912dc68003d513e5fc2ab8fde338b785e4e973abdf48f0f409c151787e48fe669ef90a965ab82964111661542ed3197fe1a2129dfd6f07c1424f5f0320e0112eac5bac811b34015ab42f9db99b679f4c22eb34136e8b708d28ae18df36d326f1a4b4b1a3de16616dceb82d0d89d58503e152f0d448a1091e2ac66bf3a45c9ae2d75e586bdc71e3052a4430d70de74d373d9821bdb9009499dcbe24621ed71590be158ac76919618fbd1546493b02167543f25dd4d7f98696ff84c26645165f443b532fdd3964171648d97a5348f98d2386b8ebc239f2a49f6eafed3f4807da6bb167906a374937fd133b2629ebc730cc974023ecb5601693be897c5f9b5350d9f4a97897e59cb522d1a4809db798fb3073ab2615a5f944142dd7364922a85bfe563e91696db51d31bd5abfcfe1b66c8925371f3b77c814afe5bb5c93b5e0a8ba5d006430e4ea351f9684b978c30ae91634497f81936b8c68cda5258caa8a4a16d75b0c5217116eb49ad8b6484b84799ec5cf7485528a25230f90506233e5bdeefe0483d277fbdbadb6f10883f7fd8e072ec843f8471f15d734ae822dac240e06457d20a2def20d3768a962f40a958fd1d33177a91bfdfd95199cb176d7802fa360c806bdbb08da2119a2e43b384378f84dc467bcf480e947122992b17a3f0e7f9af865ec1f31a80773c275796e0fbaf66d1d4ba79e79fa5e9a1c09772ef18e7bedf81bba45f2ee172a7047a709067f81a9665a35296040358227a3ff989dec0a23f0e1144f2fbb817edef8825e1a2f17041fd05aeb35548c8dbb5b6150d479db0ad75b1844d3e276d02937f1ad891eea950bca3e6f6af7cf9b7c7984cd29b586b748538ff3ba9f5f3a8d7dc0d39c7c7e81ba2661911a2a3e4ccded0be6bcd02bc68d46ae0fcaf493cbb52721872f1654f8b6b0996102f974d0fc250cb6473a6936ee3e28592b1e477a86e94057c0e9b07cfeecf009198ab47e608aaa50e733226b4358e56453fe24789d167a471f302f8a996b93bda80d06b620f4989e0e1d7a729b234e32d2f756a6498382c92c8e617b9d78658f39cf0aaa7b39f355d9ea899f23dca134667fa4e4959b1beef7cfcde85631d876c5e9a3ad052c1ea9dfd1c2caac78d872252b186950d3f8f5fd8331e5a153339ba6a7fe3112480783c505817c30aeeb027c0d8531ecf3ac955a50f1f8efc9457c5efaa236d083f561b79c17669b1562ca7b49b35c5a7d9a1b4dab98f889f33342b0ffbba4492153cf1c3f543e72a2e8f40970e2fb37fadadcca46dc5c1cf621b5e90931f5797576192159544cf41b7c2a1b76102363084f0ee6b3bf1cc70250a7d6e51a9c2f0b74784397602d85c94827201884831acc4bfd84169745e51af455aeb0e2ac7f3353fc4aa605944bf1170c8d688efe6621bc030bcf679146a379e992bbd0f7265bb70ec18fc44ccdc737369798e15b63a9637985ebc7318ba38c08fa36ff61d7b51345e73f488d41a77e739ab5fb28295518de96ccf29d22156cd99ab9808f358eb2f43453712aacea84b27b2bf1969d962a312a5c2aab27c8571a7359af7843aaf8ea749377e641c2f1555b30c746b3d59927b1e904bf7252e63a68c910e98b04a16ef652376762c9d33f86a1243dc03bd00ee8e779b27e40b72049ce46002f9c1f7f08e77459da948f4f3464ab5c55cb9f4cc90c5902c472f2e7ae18318826951f5294b5766663ad345c0c1f2c23fad1ca2c2a5febfe9f81eb243919f3eb09dbfcebc0d92a64360b87549b229e45d92219bdab1847346dba1550ec90e780e54e4b6b86643809fb974ec018a8818fb0db0fcee151ee57ffd5d2b12e222839a343030292058d7d53178a612b7a5f884ad5ca99cd1c062c3b674d608aefb0191b6a4ecc511d8b8fad440500a8d182e6faabb37f91684662fbc1cbb516280822055385fdf6963539491eebf2dbbce1fb726bef3dc6a53bbbdc5285d2ae0865f646e56b549cfab400ef2d88456de4eb36d3d6a3e22f8b8a5a81da40d9d9b11e0e13df810a234882413b6c8308898bb9ff6a45278ceccc2cd6eedd609eccda9b9ca88225ab432d4e07a0450a137f4dd5869db0f4501b8e7ccae3431daadddde26a6bee9a6a56421a7c6508f90f1cc74ddd8a0634e948d9db4e9a856d59c2a752478cfff0fb822d9062846a2416d02d6442deb90ad73d21ef346048c2c8e18be96b8fb29767229447f919be858acba78ba1ce42e82855f3fcdec79f2456011269ab277f5567ab7867f420a27d3e5ce81f1cdc19c61a7f629138cac548b007fb3576732cc13a766a9bf4ed17e6ed1d76b5f9c58a7aee9eff9cf3e96ba4f4bd3aa70980e507869c69147c7947b50e7c43f3a9bff270ca3036cfdd8a9c4aa023589d63603023b6167a1bc77c9bc790f828278404e5005a9593f09985c1e8a3465933b0ee76c978e35d4140c585c2de159c2e68439ae585f1c8716c4cf193592bf12af0d5c940a87b1543e7bb84ba5639f3a37dbad4cf44c5870a9fda6afb429144e45315d3b8c97f0a86416289d2c1f1ba55cfa796f4b41439a6c15b81b1487ced84391905a14b59fd227a15a7b1a9d40930c1a32060f11aa990fbefcf3a20f78a6dd3e0210268285cfdd43743a2aeaceec2df20a14264d74b8abba470eddf49becca5f6bdcfecc5ac80021ce32f9e620b5a979c72f53816502f85ac92d8a4a7dc71c50aba304b1995eef9c24314b4f4c8a968b4c459988ab30b3f8b518c5a5a75aec85ac653b19e405d8c458a83c2e699ce051ce5634bfeeed2ee85790ed8a7120b129ebf81fbdc45db590fc2fb5f16620a7a7458759317970f196712947af8b6da220da5acd6695438cb4a033a9015e3c02c6366d677948ebb532abb901ff88852d340227058f11af32f80953f5c93b5cb9e8e672ab97c40de8457388642116f2e25159adf73c3cb16b51d60ec14df1c26834006aa3f35df66ef5bf2d6fce5f15118c050ad02cd5b00f18cd7cec3ffd20f23e9b888f179d72c6984e758cc61118645f3dd12c3ad374554759c9811d5e0de450f952124dfcc5e2ebfefd2cf963ec87ff1b6a63afd9463a65e9d215cd8661bd826d6034d15629a3c68f98a577dc754886c5ed7f7d617bf898870372e58b8b37b95e0bc58c657ce0b2069e90071d8888ffba408b6c6718188fc75f424517eb4e76314352605a59fb2e36f09113e86557990e729e405ce394f42e09f4c615a81b9f986f73c0ca1d15ec356f53f1c69580efff043fc86f70d7661476224da9f02a48365a98f0920ec05f1eb52b89104c294d1cbdd8aa682e336622b4e986c3a28debb38140f2b24bed33e8d5255af795feaab397ccd609e34de9818308913cd28ce58b888ed78a832b0ca7e6e9011b89a4f44e365fd8fd79735e50c316817dada8bccfadf7ff1807aee2ed3af6b722a8b3aa88d26bcc095e55197e590bd60ee1d130ab9136445b9cd6ddd495a681ef334ae5314219fd480f1d5b575707d49c87d068ec71a5d41c634c004dd2e8c0c1189ff4ff1ad3a8020ab0d2b820c65f740b43aaf2699e0bd159306f84cd34c1dc77190cb96ffae78d1bfa1ef0d14a58be7cdb32b9cf9e1cea491c06790196a7826eee710219c0630de36a17defa557f4a8f6f195272490291d38026ae8e77a79985c4fa8f0004f57096477df88797134aafe4049871073a838cbbef7332c33580bff646c9fdb4de5d04364f8517063a02cb07dc1553574004067e2e34c54db4809fc317b97893521e9dc3823936e7b545ba80ce50e3414d0a3ad6c6cbd4f4936ab7b940849516e40725fe7acaa49e602ba16321f52803dc679e2d3e6a506f42c4c37cb9a6fa3ebc64fe10a7c23ee69ea9ff7dc80d6f54c4059b75ccfff0fc8eb9368db976b6836beb93edf2eae121686710ae16de47b4c6213a7a785f8fbd8afbe6df833f5c8954b09d91f685118083920a8d7da81151a4f11cdab8bd6f9eb3e4b0690b778fd9a0f6094a114f88561f8c140d131bcb7067e85824b0528ea0eb62b0ac5b32e5a73dd22358682c0566113bdefdfa0f82a8ceb3b01a5de8711e7e651b497c0068d07b936dc18e4b51cfdf6c48b23e82219438352b1a36d48f0dc9e61a9d68ae1c9d6553f23d29bcf4b9f20357aaf178ec77d5855b673361e5c2023c14060b268563eb95005cab73d200128dd78fd3341c0a1fb51d4b3217f74aa2e7446d0d34900d806f75937cf55e879b0ef73f20f54635dffaf8cdb205fbf8af0d1ec2f55d5f2f8f8c27a63f3adc7d1ced8202db09975e32a68ccca237baef5905899f694a0b608ef89f8f1d3b38fcfe0cda42f63cdf90f8bae4466e10c53a41d5ac9b28adc008192b273da2aede024fa9acd10d45bcc694d4bb1d7b43ca6e6cff61558c6ded3a5838af363caab949686bd9a873a23c55963dac2b1c355ec4055912e1f2bf67ab3dfa2ba295107a58cd7e4762fdf20262de1da657262ba5ae27f751919da6a7af150642d1cbf1680c697d26f24a6ff855271fc22be8c658c801165769c55ffa7b3b1aa1100ac5d34f57299cb52f06919ac676aae8cd7893a2112fd1d898b83c970fc33155ef90c47f07f153b2a41b070649fc87d825c8db60f4c6130c82db0330b4f7a25765af1661846aefd19647b74fad5c317bb11ffb7853d7251e75848b0f93250a56d15fa35e7db5d888de1504e19051e2b5302874e23507ec67de734cf4661db2f8c0bebbc5b0dc3b6faa620c6d6a138cd901c6a2ab3e638a6d38e445040e1ee15bf4ed197a5752607f6371dd572ba7eb3c315c833cad30fc8102e0a991282c854a8cee2c7196a0600c5b15e9f323c624bdc4b445aa2a38228f4052922903e6bb9da97faef085d1f6f2c4a9f489473bd6ece1d1860a6bc4cc625942ec69e375d299727c89bd887919ab8fb059704d1f13d4ab68ed5fea327cc1593aadcdc5b45f855c8804b74bf684f8df6f1ffb393bc599cb4404c2f24f7316ad97320d6c44eca1d08b5340a7ff870f4b00796dd820715d07ca7c4b0caa995913508ac6d4d9f4e90eda7fc0f517dfd3d54ef6c3c97689db23ba2068807c2efb3033e324cb741188c1f6560f9f2cb39476e6f7970824e8b0077566a7ed83615cc9868f1d8661316bd2778f2c344699ac9cdf31624a8c99ce6fe5fd107f233ae4af01115c81eafa9b851ab5902023fd0d5537ceff806706b8b4235c16d043a02e28744b59ad96072e8c878f962d5a155ff2dd5fef0770fdbbe00a746cfb0ce8a49371cd5f3c1254d8869edfee8894f1905e23bd9a490ba9a4c992f3d751c0a9c8ef60415a6aa847c8d831c97a01f2c7ecf5dbe59f02cf62f4a4de40496755eb5dea1f5226e89b1fa80f5474f0a6ad55c00de13f6efea1071487f01ac742ade219f869efb0f7b5b05d7160e13be1c1428414c028828ea1dcb8071e22025841fab220e9dec559eb0d22d36dd8df868ea60a4262d6753218859c1086536c525418f1556e2551a85bdd32da0efac5496f907e91a056116b083289b2b70137c66d7f14282c467d0e1a7d89d8880e7e76f22cd62fb191e7c69329b882814995bad367852d825e3d6ab3981025f66f788128a37e7c1aabca59b7bca243897813c505e6c2c80e4c249b86ca15eb2639fcbe3289332eea681944a82654124ada9ff774e1419a5f77bc6614154001545dd0e883aee64d947a5a227af5585c1ca84baf81c4eed8511f7f16a36a0017f04c1e69330e76fe789aea51dd1cf8d72f85efe1dd13df4f3637ebc91c7a416a52ccfd69bd1d452ad94e54cf0a7afed39a31f97de3c8ca5ef44e6bc905e37ab80ea01eb2c685bc38dc9cbeb42860919262e03911fb245d5045f1fe95d3a2e2145de55fdaca33f73dcfdd867f8be73d63e837cd5b1e6ab52f60d52b77ba77897cfadbc36115ed45c982332fc610331391401d039b04923ab81b2a35d3ae27e4743f328943c6b7b338d7dc304e270047a008125d6a9cbfbb411f4555142a1d247b839cd1f9ca49a2a166ea7336e0ec087f191f7716689b9cb5579c18ffbcf1c9c48d3c34bb93386d9339888092429c31cc7c266172314b7bb83ff8e96c1bb0ed60339792fec48242ceff35a67ba27b0366d228fdac8655adec0619b0060a3f5e8160de9c0703c9829ff8237dce0126b5d51ff4c5e5f1902c270117c6fe87bdd7331bf0d8ac08fda24b8595caebb53bd04e8751d65f1209525f9561dd31ad6fe893a81cc7844682506a0172f65d9eb98445ade5cd396b43261c4599f3b00bfd26492430e8e945818ecea3814995af6f9d0afbec339e56f13763ed2605623f95b588522f87f346028a121f5add7ff086e2555d7e20e0dcbd3a902969b52c26f222140fbf39f50e096fac53c2bb062c56f7902436ce4f1cd4944be0ab44cc8f2f3bfa175089a0e7ac822ba0011d88488cb16ea787ab8a7fe73b35177480e7245b32d0ed885ea0fa5668db8390abd5120631ea72f9cd880d5d54c0d965ba0087637860f856795e42354f3cb8cd60b13699c694408a2f68717d93b7597efabf1a726ee54eebf20c9d7030459b761083b5ad974fd01e549ff560fd23e34134a00fef3afc07e8022629143ba02f2c469d5465cf6a8e25bae14dcd418235a472750909d203351a1223889f9272d8d8ce138b4ab54e20068bb8cc03a91a1a546d18485bd2a7014f9322725b9968676e6484e644e2210c551df61bb2bd5feaa648c0c3f7850f03c32ede270aa84de93df14242039862355c522534c9895159401d3bb9a868bf9809a85d4c704af785121bb3d79d6f8e72537b6d7e692c9c2989bf538f2b08d3ba778f825fd10adb748b79bc8d6a44850b8a732e4bc09f61a27a0c4d47991957f4003ef99af6c225755ee7aa452b6ac054c5b821de2c5ea49f3a8345e2edc3f77f36f1d820986ad860fe8ec7988ab1a8482f5e31b2a1729276e84d2804ba03508018ea8f4467306fbbccf6bdb4cef80a07784eb2047bfd04db161208dc92347b1d06a92f1f47827ead60b57055797fa82aef8ce5bbf3dae28f9294b475499f67d67f0c2d2d210597a2ea9944f5bf8649fea879f142f6516e1cd581b1b9802d5ec681b50680525d78084a22b440bfdf1c565b4c8fb4706ace00c5fd256cabcd1e1ec4761bf424a851f6601cb28d00622aa6397730b0287bdd74d8330e65ba651a6c38528c5b2a8247cd2faa72fc5f5f0bf8019a6164da6686ac79deb2efc0f6bbb625005904f282b5fb6d8fd50da96a61928c9fc9d7b6042f36391c54c2f0bf495888ba335040546addc7453fc199d3daea68b9e7b475c98f2ef4aa50ca350f6d4eeffda8350d371813f5070f0be22aeaa2867d7c6fbf56413bafe44b78ead6c41516ca23e90407b92468b9cbbe53483c928b93f59520bcb96e48b56dd2383279d42f3eb9be56a7ca7eef697ac56f5b4dfa1afebbce28b78c24cb9896a87e910fd02cbf874863c59dd13f8aa3f8bc5b034d41cdc928e195b0055f3b347fb4d195ba6703aa29546fe888fe5e17a520fe83ab0c2c970936e35af220c07e2359bc8e6bef4932c8e4efe52588560a8cb7899fcbb0ce5be4c273fbd964b4b2696c473555be2f0a199b500e28a24b65cb4df1f47305aaeed500ef656e1288b974c6b9f10858656a82b12e0392f5331fb528876fee933c0597078e4dd9cf3f55ac1e27bd8edf1d3e0824d127685e1505e393c1178f39e53e00c4925e8170203b010313e7f806ad4fc27a22e96edebbb614d7b4c960b1b7373e759c6ec4f19a8676477d6034e75303fb4dae342e8166e22a37ca797e76dc70dceedf304d4422799a1dbc5b86bb012a8dab82be3a11a5ff1cebeac5bc88062ab990b81e544af0477e07296c4c157820ad7e21b4a0c1eafac4ee5d924d3f03ab24e7e0d8579cdff21566bd5cf047161ba663366986b218d83e6ae68379aa0660c603735a1687169b531815d484b0385dd2ff5e680308f15406eaf501bcb00ebd4d22f4786e86c21ad6836b0e730ef839597a0ee497b68396321dcd16309ebde92ca5f3cd0827c06589b034a93787dc4d0b17c540080d454486bc0795da47a72c315c991cdad67dbf05e5204da77334e3f3b944dc5040234cd35433c67ffe482677dfd0b735cb2e171b3c91ca8e8974e08c872cd490665a97abfe445d83ca43b5e841b2fc44c05bbdc5e5eda9677c3f765302425a5f3463cbcb4f0d80f57b77d115cb417f12dcee64a7a65a7b1981a52f5891b93e6d1d93d513194b802fd3b88aa46a27777db2dcd5e7e32e11376fdc683881e29ec01528baae020641cc2ab5821648d205b14f7f80bd06fbbbd533d7d23c3b7d407c9feb9bc985ac7bb1df5d4aabb97ca0fa49c65bd0a801998860a16ab51b45e0921fcf2b3cdc4c2e016f64b3b16349c7ae354dc2c619ab2f056d0171dcdfa9171057f562f54e346b5c68260b5a4d2bc23764bb1c6ae15d49e2304ed414f388cf19bead41b61603905e15e6fa909ddf04cd5161888087b1f237c0c030a52ec1af6f78fcee4a376a991104b8ae945997d7b1ab6da12ab4730c5295603b13ab38b1187663f3ec15605c0152c5d470f8436ab366b98f24821f5a793f3846227719e78ee0613f308c3223b90a1f8096f9c9a87bbed5161d577b3857d2841225aa296649cc7c21da3f104100f4d1b2426b6d3a5375a977db849fe8af0f7cb55c45c0625fe1fc42a5a9ee0b53c65076a1d6018cd4c3208373166d2601bebf6f6533e92dd44ef35e038fcee285377e915fe482ad55a4ca5ba3bad0ab46b7402c9a65d39d96d5b7291bd27ef1d421729cd72610204024c1262fb09b808c993d7037818334cb18013bf5fa5c6ae142c8f891938820d342712bdae73d2a286d5b6aa6d926894135dfcef16aae2f05499f7ff7557a1eec5d9be6cf875710fb4e3a0c80bd59b157c19f983106cb08f1cf9d58375c601013bb0f60da691c6997f3239b8c34735aab877e3804ca6d205b6ef9f53302735ed6b126057b4497867b1df1f0f102f3d872e29f30649532fe1b77aa56db094ee22f8f07d0ab3ad5adf3d61b64318a851e731e9fec50e596b54ff2ba53f8b481779f9aa762dee25459152ce467bfbd981bc235fab97edc96136224858533804bebd2123b7a1e18d9fcf2dd003aa0d90aff9bb4e110fd1ba246e75463d8a8cc4cd8e754fb6a6f8e8c631add50149d3d738552e5bd857520d85decb07cdf585bd5246da8178f6d84230ad5c0cf7b4140f97910fda8393a6dcfe70d5757a11e1cecbf7a58c1f04503ee9e7101cc2d9f3a7b4d5eead0a5f4b3e12c7e82097a8e91a598f484ad0d3c94c26f2d122c1a9be71ff2964c6a4fc446fbeb809cb5ae450631c58a39ce22be0acb975194bcbacf3f21010d5d59a6c85548aab44288259f68825ea46f251f27c7bed06862561f3bd018570645274eb629224487e8a8b52a5a367efbdaceca793bf67fffa01b14cabe2620259712747fde3128d4fe9e1b921457d9c002095093422edaf39b13f2f4c260361b11208d6d7d499000cf700689c3c3b870d039a83b1a5435d71ef8629ccf09ab71ef86e7aacfe182d94fc871be8a3902be4ca2463d240c3c0740da57530395b7082ea9185940e1d66868cb04264065692fd325860ffcc0b80cb2bc182e13b26f3a156d630788cede55d1eef2c8acea744429a2b782b67518882facc34b7b9e53f9f97a81c8b2c40f60060d7330d8430e1116297ea42382b7f3f839904517be8e4384f61bc4ba994bcf5e3cd0fdafbdb0e3f6eb07c0b3947db1a43a1166cebced41726b108adc792a3e3bf823505e830174a9648d79dc8d5dbd34de4e2e50ff34d00462c649ab9c5673430f6906fd82c35bfc9f6ca3cb796f65ddb61e4f890336e351aa7d8168491949174b833cb33055d3a0c8722c4265007ff291a040cc06523ca438cf1bdb1a9b4d8b4a40e6a7c46765dc5b902440c48d968e1cafa89b7c77da80de5a2e89c99d8a4f1084f8cb5327d24dedfe9b5570a649dcccebe2a4abf251f0201dcd5537dd974ebd7544b432266093128789822dd7cdaa02d8f28ae4601feb1b51e387d433c6f2d69a50ea6bfe09c8f65956731fc9c7dcb8e586839e0a343a3d47fce8ddaa002e16cbf5be85155e8af20d3c83018429eb42a1e91ed6f09f69089698fcf479038656ee0aebf49ee64e271af7737c7e725e40194652f214bec714bec96ce76eae2eb32906dc84a32ec115922bbc079020b359009a530c4e9cddf8db3bc4dba7dc46628bf91a8e1449169ed2a08b6328622eda0ffab2b8f7d9669e601372fbae59d9c25a5fadc82d2817e13c02508f4dea4f1f25b32162bab0acafd4dc1142a307859e008f3bfadc268126fd9f41810e9a23d8d11decca0cffbaf9c01ea161a08d06faa6fa6b17f61d6d6ccbab9b88415f069b21e39835ce7fd987ff05da0404af5332b182f1b8e5e3fc950981b86fe4b3b85fa6ec797d8d1768213438e19624027cb59e34f0243fe0f7b58b48be37baa68832e41a3c8127802ae06533faa0ff9618147cb0bb5d6a4c61828f27aa3c41c0123fe84c9914c8b12f045ecca5652714569234e830c251b036d92837593d40c0b1e484f710402467d31b32e01e6848e00f34d701a153cc0827bb7e78b64f1cd8eff032c4f4ac56249068feff78604e2f9c0e4b2c2cfd29ee253bb0ce80671b93414cab782aced2fe2556d0f2cc5611a311a02ad925394314e3c95ea4f88903f4b802f25152a2977ec30ced83645136b3055fa14f2452cf01e4db5c65098290811fe10f5ff61cf3aa8a65bf6ce19f650e82f196f3ca9f287fce315ae1649c5313fa8b4d5af29c156a150bee2ba05b79c9f2c37959f7f7137dc14324503a6872c8b25ce8ecac70d750fca722029b39362b16eb767ccd17f80ec3077074f1fb52f44b5fbf3421fccadc82ef731fb200ee3939a56a2aba8a4ea9856e2c123bef417d89702127e2eeded59d12b57c3c739261468a336b59c3738836532966f195055847920b6013f9c676f96a51cf27927979d830723956e1247ae86def46c2f6d67d2812c2ff0ef3beeb67fb2dcfd02579e44fcd58f6e4c1131e981010dc4144d72b088236ea05c5b99dff0e586e521eafaede0f18fd09ce72f0eb72d24e0d3af91efe4b43c41633194ea7c9144acaf5c84fd6ede02ab5c35d417f6b29638f4fa5487938560b3a9a3933b2c19cd37ae328897ed863507357921d3afee5bcda59d39391fe134f4f419d087c726971fbc70fdffb19ccb76daa864562f81862bcc0f64cb9e2fcabe525ec42988948cf7ff159b46a768d3c86efd01907096f33258b1dc3ea6dc845241af60e9b65a2391652794295c5280b7fab5fc53b62daba7a13c14293c38b1f49708189d0b012cfb5f7a2cd7ace93604f8b9c898f1a5d9424549a255f9ef5f4ec0788e92cc40bf270e46b8eabaa2d31be84d7def643031c914ed6dab2cf3a4fa599cf3270be58e0619a87189aa1f7018468a53dc2e7934a2e1c23c68f4c4fcf0ba9e6473f9ff1fa32ec9630a1213297c6efc6f5a8b0f4c8b9d49d1e60baf23e346ca064431ad63f910c57563e9444b0df176e291aa2e886fd89760e710ef66fb7ee9eb41ce5f9682ca097f73eb23b4070d7e2071ba9edae9fa7297edbce08bd8b05fabc6fcf2f0c1076ec5efab33b932c68bda930102396428d7b4c8211fbea4c12cbf93a64b09c02edc7914ad79b1354770f9aacd58ae374ae07f6cea6dfd19702620b3495ac89ef6163c842da5777eff8a725d37990c55b4006199e3151234b9980487d0e375259cb448362a75cf170d1b823dcdb0aaadc0aca059bd766be47d280cebc1b9488372555bf9a9b79e38f92b8b93e2533cdb99d403ee870dc25c99928f54579e19100b273c4d9aad02e18059914ba436e1de4f4f379ef55c73cb9baf1f9e428845a35698098478447ed8565c8a9b56f11d90a68ac53825d6e41272a39ce8ce8ae7394a5685c5384af06e736bf5cd983b100e1cb04885a751de7233957dc87599aa7d6f922bb5ba18e1afd987b9ab20b6ad6a83975a1f9670b137a695f20b4e99b184c22298539a22d7bea02828e401684d022a8f75cc8ab1b5ec559aa40e86adf9c783f2e0dfd259175026a28146cae4d082e16d67a972d8f09f2a5dde1a83c960acff272ae6a8063a0f92ca83744a8b792fc8971ad2b77e41ca226668ec52b035f59ae76f16aacf3b44839fb851d1e0b7f2ef4c94c5f14b7d70ce56338aec36279084ccbf5641478fcdb0177b2e3952c1f8e8a5cd1710d4e7a5930335072d46c58b788063d6ccd3b1f44bbdd6308962bd4950f49524ed9cb72c9956091ea43ae2acdaa98d7e152afe834caed6dbcfc3b3165f25eed459a5014591c2bc727a2396025228b8fcb7fd539a094c5284a50444c684c56bcc7529bb419baa0b4b8be5c5dfd9aa8aead3f584d2fa29baf084d9f5067416291668fb15449526da63f216b4a9e8fc37ae8412a74c4ea142308cfb1a2d29254ac632ce1443aebe8b0c7f448a03580b80812198deac497bf6e1786f2f3e353b6457c758d8c82491ec62e16d7ac71f635667682fdee7827827a5c0fae7477e9b6e487557ec7617e5fc60820d9f573dce031f15d5161a38a13011ed8a966fc70b9910a95f57782c84964792de1ad993530be58c5c8981a37a4538e0250aa9b91a6227402d9519577136cb3353442e09f51c48862f23c4ba38cf7831b57e7711fa6e7285cd32ae177a6371b28a00dad1403c197a2b56e5efff6b8b545898f377bc12a466ed24511db608906bb0f245cf0aab7ce76e0d66e37fa8f74c98843990306c9e4c621908788ac3cc61425e77b95c21ac5ba0e56c7411d514dbd40fe30635e0d5b7e132ffcd5fa53e01a8ee6bc5ff28a571ac3bc6bf8edd78688eb143cbc4fa97013128f579b06531b7993081707e31b0fc2efb0aebc19930a9c41f991a0be3bff4ed8f1a8e52cb3c23ee9aa88b258140010541f768e2b9a9d684969cfe3af626007dcda9b3c48dd61bb7f88818b03d9c73f861ecbfcb7a9a7e40247af33174b3e86df404020afe16ce2577d7b73fc32fea64d602c72c3af0edb92623ed0cee6de0c4b50f02a3f7a824b1588bc87189f405ba448625e2bedfc3cdb137a44591abca9da220c58dbf4569ff5e150d325693e848fb4875473d51473e32e6f20ad74be7d768f3994c1ae21c49f09cb4dd831ace049691c57de4be79020edf4f6fee4bc7f35d424aa8c3f5927f49cab4dc1802d91387da51d7451efb85893399ea91e1d6e6a88966e229adbbdffd40fd5ad754bf8655e9080ab2d53ea5892ddfe3614b8473d897e1fe3da02b6f9016ac52fb0c252def63b6a7687d352f623fe1cfa17da3119b775e9c41edd48d2fa64bcaa02d3484b760e3a8b2878e722f496a485e77c3ca7479e43f798c8486a68c35a5b103a2b5664bcda855f67dfd48d2789ca394773efcdd0ec1ab7473f6236eb055b6ab8d8d3b255ee787fb89b69f101e7480d3f61d8c403831e5c56039a688e446751a9ea4dd7e8836bb4548cf3d7551fa8dda841dba8ebd4b5576a3877e5c08e890d5f43b1cfb03daa5169b902b39d35a467ac9aea918e9797f57fb987f708c906f2481eb5407da5d5aa427c8a5104a70e5a888843209a04f182b3036f5dd855d1d4a2753dadc5b007e06032b949c13bd48166b968bdf68ad4d88171780fff6d5a5faadc270891f37a92a106bc3e1c425d25363d24b0deef79f24aa52e4fb7b677ae083b15cc7663ffdb0e94cfb6cd656eadf84078b67f539cdf4fe260bcbd1da25dcd01331b3ae272c84158b95e7922e4b7a31afffa569a92b01a913b9ab5995fd1ed021d76a562913980096da0bd48116a38259325f6ea6db89b4d34453d3fa8a1f8a511df062bf125bc9ee1130e36fb667075a3d640d3df8b51d5993a1c451f741d2da4e79c2d754693b2fefa4d4f1468a743dc3144d0bf4df5d8ec47f1d9672a6a3d137e9aebbedde14986eb017b72f0b4c51ff0dcff9ed57a4548be0cba52ff8f421bb33177593c28b4db57d87a6e40a55de15ce242401c91acbe2cd1f21fb4e43aafc12edddb0cdf06de4b923e8d4536c68029c49e42eb638943d5c5ae459670d2825c8f7571cf244e4d79c881b30349677f6615a0320e0a94802fc83c1b2f8b386d721bbf9d6ab28664fb770d221fd9bb99662fb35cf998cb1b3ec82b0ed23e521e0922e45571578a644fbf47ce3e529d17d5d77ecbe12d6774fbf699479743f4a95d51ae754462af1cf91ac6dbdcc66b0a9e798e337ddccd407887d67da090e19fdf5d98606fdf50645fa0cb0cf5989898d25401bad25a2211b7c32f2753715bc536faa847eb7ca74fcd13a9f80b7ece7c9a0593247ead92d1fa2f00b3fceabf6c5c381033a2d2fce8419a0c9763ba64a6244901c6815766587c0913e58b237e2c3815d3a43ab998b1dbd76474bf1bd4e3e9391d42aee95c86db2a926182cbaa194611ff95da0674e2fe2f6e825f7ca57b9d7ad495bcd7f4486d78192f088bd13bd55183f4c65289b69cb7f3c1a558a7957fce209ec457ed0f9eb78c03cff2c427e6c9a8776f470256d2ed8e150a7c1600fca7cc7613885baafc9c491a628e4fe1169c8331cc65f636a92e4068726cc6ebaeb0cd7492c498297a09edc71d19340c73f5907ab090129027806a5f44b05e233da7f73bc0209039646b69cbd652993c173f6e5d8f7f1aed0e3489084dd6f4cfcd17ac039e165c9c41fc12b03979ab51a1961a89689d0b88d2c8a028064114568e3040d41f60ddc7deea3ed02df7f5d97070b01988074c0f41f9a302d712bdb3af0e121e96ca669e2c70cbdbc9b069483dfa2f5a619f5f7fab58574cf7da938ffe7e6d17e1aa8bea46a9f9a61e4ae98b0b6236eb1ceac34014aed49f3eff1a5251a35d46b3336467dda332728cd7f9c2dc6a23036dfa023435b36308200d9090a4fb26f5960c8b46e9029007ddc256f10c0553e7fcd5746a2c50828235f821b9cc8f1620b5386523281eaebb25d2bba12189e9758f19ec3d3550b9c6634ecbcb648dcb982bc9fe0bdcf6634db1cdb3a37cfa44a77b9a984c5e45b5281598106efbfa4e98f3b3af4d5473e9e481ef4fdf2ff4a66a7a160bd909be1448311f71355727a5082c6d4e9b13daf767a0b8df46f1ebccbc28b1f383c0b39ea13c234fbcb6164c43af41ff3dad9d66454c91252777feda4f2cf01447cca2b3b65f3ccd1c2743162f90dc69862906d883e29e9a618b886f7bc82e676d84ad2b59a50e2543537ccb0e506ff84191423245bcc347d3fd6881438bccbc6a9f47179f2f6df91a4da85320cbe0bc9a4b62788a861fc984edc0967b952687ed2e75815be5965b93b7ad1d8389bf743707963240a26d1a8e77e4d301fcfed34f2541033af9a485b6d06d76ae5813feeb1f40290cc6e096fdcaa895a0c74765fa7e801e212bcdc7a637181593c12301acbaeb5ec583632ed79e64dac0b39b3c4585c767727d18ff3472ef068ac128a6e9721736d7d90a0ff164c8c60e34dfb43a8ae4fbba51456cc935a8a01beb88f141de740c2fb847f152c7b3f23262be5c596fdcf791e67896269288b84f35a4c76c1088792bf20c807aea0cf72289397cddf635755eed092c1dc03df56b5b62a9f767f4a911a89ada37dcb1bdb23ce4aa4f18f3bba67cdf2b28dc23ec28f6327298a4d8af50b755ed8cec6d5f49d405168f035a5d2243ebf2442844688063444e01dc41cbe6d490339f11f8b15395b022bfa8540db861391a0015575c2898d4045e5bf95543727b59029bf2e50e1947eb1fc4aa6c72477b5eaa8157b535ead6699cf292c5387646e077730cb7fb6e3d8c81bbfed424b79c286d941a1984610e603bce513b87279a1d68311f31c6d66ac90d0d266aced03704b8405e0c38d00508bd7d287037d1e6fba42d5be78f9fc96fc0d3bded872f05c5efad7bbd99af05c7608cca0926d0be87a5775473786387cc6f2257371f797aa74abd5938d8385187d4d6e9d6e9811c0051da8eda9d963afdb20638803467d71a9b250c906f1f97b1de33bfb5c171e6ee77823cc3e0ec5bcb98e79ba44498c5addbea2f9b18d6af41ee65d2d87a892b048691cf63104bddd5be0666e7c322399263ba50d810f858bfdf9c029441b60b7b0532d475d903a1fcd3c0c789a9a68c868bd6054295d9454131128e3b603223fb6e57f1bd275cea2ea50dcd2702cc71546c834bf482ec16eecf84728b98f8c872b1ad233e24136d24ec24040d07f95052f7eeb980f06a70b5894375445d6ef499fc492d19a56f60449e3a5c41e42302509256396d5c5e13d0e87ab54521c9dce49bdc6714dff22367ce3e60237ce9795461def2a9099f0e229097587da6c3a3d43643d5e203c86791ba54adbea4d0e8f15ee324421d8c8d081759e5f90c5350d3c4d8ef0f7f582ac0a8c3b9ac3ccb60342cd7e80f8ad9d3369add6e92d047a63f239ee5115a73bce81ae096dfd11350657dcb6b8d303b20c05fcc0b729a776715b30499e10bd5203a24cdabd80e71087d22c07d7378d62ef80ac0e6a87f07961795aed4aaff496b3c31b6969b647dfe639b6299e5638f63631636bdc81309065d656147b1a4dc4f72bef3d5561eb7a5fab3124e4e235228d30e7a9e28672c76b686131005d6606ede67c2917772ffa1567cbb82737768f26924d7c291c67e8b330878d6589b4b68639ff8e758588e31957538d0bdf3101503a89323f0c546aad5c0b333f9e86d5ed73a939ef8478242af8e19faeb65383187a6483700a7b62b2aa48a28930110f15da9cb86e4f819a0061c1becb4f26b6b9338cf28b0debbf4bdbd2c69b41a728d7dbfcac749d2e7707cf52cb28b64073cb56ec65143843e453ff72761e68f0f8fc08923c216d9130c7cac7ef5fc70411b32840ac456f3f7881b086e8afcaf2a0b693978c781d0ff7d938d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"07a421aca9a166b2a994167b985a4dcd"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
